<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiup Lilin & Potong Kue AI - Edisi Meriah</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <!-- MediaPipe Vision Bundle -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Pacifico&display=swap');
        html, body {
            height: 100%;
            overflow: hidden; /* Mencegah scroll di mobile */
        }
        body {
            background: linear-gradient(180deg, #FFC0CB, #FFB6C1, #FF69B4);
        }
        .container-stack {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 640px; 
            max-height: 960px;
            margin: auto;
        }
        .container-stack > * {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Efek cermin */
        }
        #webcam {
            opacity: 1; 
            object-fit: cover; /* Pastikan video mengisi kontainer */
        }
        #candle_canvas {
            z-index: 10;
            cursor: pointer;
            background: transparent;
        }
        #background_canvas {
            z-index: -1;
        }
        .fancy-font {
            font-family: 'Pacifico', cursive;
        }
        .script-font {
            font-family: 'Dancing Script', cursive;
        }
    </style>
</head>
<body class="text-white flex flex-col items-center justify-center p-4 font-sans">

    <div id="main-content" class="flex flex-col items-center justify-center w-full h-full">
        <h1 class="text-5xl md:text-6xl font-bold mb-2 text-center fancy-font text-pink-900 drop-shadow-lg">Make a Wish!</h1>
        <p id="status" class="mb-4 text-center text-pink-100 text-lg">Arahkan wajah ke kamera dan tiup lilinnya.</p>

        <!-- Kontainer untuk Video dan Canvas -->
        <div id="container" class="container-stack rounded-lg shadow-2xl overflow-hidden w-full aspect-[9/16]">
            <canvas id="background_canvas" style="transform: none;"></canvas>
            <video id="webcam" muted autoplay playsinline></video>
            <canvas id="candle_canvas"></canvas>
        </div>

        <!-- Tombol Kontrol -->
        <div class="flex space-x-4 mt-4">
            <button id="enableCam" class="px-6 py-3 bg-pink-500 hover:bg-pink-600 rounded-full text-lg font-semibold transition-all shadow-xl text-white transform hover:scale-105">
                Mulai Kamera
            </button>
            <button id="muteBtn" class="hidden px-6 py-3 bg-purple-500 hover:bg-purple-600 rounded-full text-lg font-semibold transition-all shadow-xl text-white">
                Hening
            </button>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

        const video = document.getElementById("webcam");
        const canvas = document.getElementById("candle_canvas");
        const ctx = canvas.getContext("2d");
        const bgCanvas = document.getElementById("background_canvas");
        const bgCtx = bgCanvas.getContext("2d");
        
        const enableCamButton = document.getElementById("enableCam");
        const muteButton = document.getElementById("muteBtn");
        const statusText = document.getElementById("status");

        const BLOW_THRESHOLD = 0.5;
        const BLOW_DURATION = 1500;

        let faceLandmarker, handLandmarker, isFlameOn = true, isAudioSetup = false;
        let flameParticles = [], confettiParticles = [], sparkleParticles = [];
        
        let isBlowing = false;
        let extinguishTimeout = null;
        let isEnvelopeVisible = false, isLetterOpen = false;
        let envelopeRect = {};

        // Variabel untuk fitur potong kue
        let isCakeCuttable = false;
        let slicePath = [];
        let finalSlicePath = [];
        let isCakeCut = false;
        let sliceAnimationOffset = 0;
        let fingerPosition = null;
        

        // --- Inisialisasi Musik dengan Tone.js ---
        const reverb = new Tone.Reverb(0.5).toDestination();
        const synth = new Tone.PolySynth(Tone.FMSynth, {
            volume: 10,
            harmonicity: 3,
            modulationIndex: 10,
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 1 },
        }).connect(reverb);
        const melody = [
            { time: "0:0", note: "C4", duration: "8n" }, { time: "0:1", note: "C4", duration: "8n" }, { time: "0:2", note: "D4", duration: "4n" }, { time: "0:3", note: "C4", duration: "4n" }, { time: "1:0", note: "F4", duration: "4n" }, { time: "1:1", note: "E4", duration: "2n" },
            { time: "2:0", note: "C4", duration: "8n" }, { time: "2:1", note: "C4", duration: "8n" }, { time: "2:2", note: "D4", duration: "4n" }, { time: "2:3", note: "C4", duration: "4n" }, { time: "3:0", note: "G4", duration: "4n" }, { time: "3:1", note: "F4", duration: "2n" },
            { time: "4:0", note: "C4", duration: "8n" }, { time: "4:1", note: "C4", duration: "8n" }, { time: "4:2", note: "C5", duration: "4n" }, { time: "4:3", note: "A4", duration: "4n" }, { time: "5:0", note: "F4", duration: "4n" }, { time: "5:1", note: "E4", duration: "4n" }, { time: "5:2", note: "D4", duration: "4n" },
            { time: "6:0", note: "Bb4", duration: "8n" }, { time: "6:1", note: "Bb4", duration: "8n" }, { time: "6:2", note: "A4", duration: "4n" }, { time: "6:3", note: "F4", duration: "4n" }, { time: "7:0", note: "G4", duration: "4n" }, { time: "7:1", note: "F4", duration: "2n" }
        ];
        const part = new Tone.Part((time, value) => synth.triggerAttackRelease(value.note, value.duration, time), melody).start(0);
        part.loop = true;
        part.loopEnd = "8m";

        // --- Inisialisasi Model AI ---
        const createLandmarkers = async () => {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: "GPU" },
                outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1
            });
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            enableCamButton.disabled = false;
        };
        createLandmarkers();

        // --- Logika Kamera & Audio ---
        enableCamButton.addEventListener("click", async () => {
            if (!faceLandmarker || !handLandmarker) return;
            if (!isAudioSetup) {
                await Tone.start();
                Tone.Transport.start();
                isAudioSetup = true;
            }
            enableCamButton.classList.add("hidden");
            muteButton.classList.remove("hidden");
            statusText.textContent = "Kamera aktif! Tiup lilinnya.";
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } }).then(stream => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            });
        });
        
        muteButton.addEventListener("click", () => {
            Tone.Destination.mute = !Tone.Destination.mute;
            muteButton.textContent = Tone.Destination.mute ? "Bunyikan" : "Hening";
        });

        // --- Logika Deteksi ---
        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.readyState < 2) {
                window.requestAnimationFrame(predictWebcam);
                return;
            }
            const startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const faceResults = faceLandmarker.detectForVideo(video, startTimeMs);
                const handResults = handLandmarker.detectForVideo(video, startTimeMs);
                
                if (faceResults.faceBlendshapes && faceResults.faceBlendshapes.length > 0) {
                    const pucker = faceResults.faceBlendshapes[0].categories.find(s => s.categoryName === 'mouthPucker')?.score || 0;
                    const isCurrentlyPuckering = pucker > BLOW_THRESHOLD;

                    if (isCurrentlyPuckering && isFlameOn) {
                        if (!isBlowing) {
                            isBlowing = true;
                            statusText.textContent = "Terus tiup...";
                            extinguishTimeout = setTimeout(() => {
                                if (isBlowing) {
                                    isFlameOn = false;
                                    createConfetti(canvas.width / 2, canvas.height * 0.7);
                                    isEnvelopeVisible = true;
                                    statusText.textContent = "Ada surat untukmu! Klik amplopnya.";
                                }
                                isBlowing = false;
                                extinguishTimeout = null;
                            }, BLOW_DURATION);
                        }
                    } else {
                        if (isBlowing) {
                            isBlowing = false;
                            statusText.textContent = "Tiupan berhenti, coba lagi!";
                            clearTimeout(extinguishTimeout);
                            extinguishTimeout = null;
                        }
                    }
                } else {
                    isBlowing = false;
                }

                if (isCakeCuttable && handResults.landmarks && handResults.landmarks.length > 0) {
                    const landmarks = handResults.landmarks[0];
                    const indexFingerTip = landmarks[8];
                    
                    // âœ… REVISI: Kalkulasi X diperbaiki untuk gerakan yang benar
                    const fingerX = indexFingerTip.x * canvas.width;
                    const fingerY = indexFingerTip.y * canvas.height;
                    
                    fingerPosition = { x: fingerX, y: fingerY };

                    if (slicePath.length === 0 || (Math.abs(fingerX - slicePath[slicePath.length-1].x) > 3 || Math.abs(fingerY - slicePath[slicePath.length-1].y) > 3)) {
                        slicePath.push({ x: fingerX, y: fingerY });
                    }
                } else {
                    fingerPosition = null;
                    if (isCakeCuttable && slicePath.length > 1) {
                        const cakeRect = getCakeRect();
                        const startPoint = slicePath[0];
                        const endPoint = slicePath[slicePath.length - 1];

                        if (startPoint.y < cakeRect.y && endPoint.y > cakeRect.y + cakeRect.height / 2) {
                            isCakeCut = true;
                            finalSlicePath = [...slicePath];
                            isCakeCuttable = false;
                            slicePath = [];
                            statusText.textContent = "Selamat menikmati kuenya! Klik untuk mengulang.";
                        } else {
                            slicePath = []; 
                        }
                    }
                }
            }
            
            drawElements();
            window.requestAnimationFrame(predictWebcam);
        }
        
        function resizeCanvases() {
            const container = document.getElementById('container');
            const { width, height } = container.getBoundingClientRect();
            canvas.width = bgCanvas.width = width;
            canvas.height = bgCanvas.height = height;
            drawElements();
        }
        window.addEventListener('resize', resizeCanvases);

        // --- Logika Menggambar ---
        function updateSliceAnimation() {
            if (sliceAnimationOffset < canvas.width * 0.1) {
                sliceAnimationOffset += 0.5;
            }
        }

        function drawElements() {
            if (!canvas.width || !canvas.height) { 
                const container = document.getElementById('container');
                const { width, height } = container.getBoundingClientRect();
                canvas.width = bgCanvas.width = width;
                canvas.height = bgCanvas.height = height;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            
            updateAndDrawSparkles();
            
            if (isCakeCut) {
                updateSliceAnimation();
                drawSplitCake();
            } else {
                drawFullCake();
            }

            if (!isFlameOn && !isEnvelopeVisible && !isLetterOpen) {
                updateAndDrawConfetti();
            }

            if (isEnvelopeVisible) drawEnvelope();
            if (isLetterOpen) drawLetter();

            if (isCakeCuttable) {
                drawFingerIndicator();
            }
        }

        function getCakeRect() {
            const cakeWidth = canvas.width * 0.5; 
            const cakeHeight = cakeWidth * 0.5;
            const plateHeight = canvas.height * 0.02;
            const cakeY = canvas.height - cakeHeight - plateHeight;
            const cakeX = canvas.width / 2 - cakeWidth / 2;
            const topCakeHeight = cakeHeight * 0.5;
            const topCakeY = cakeY - topCakeHeight + 1;
            return { x: cakeX, y: topCakeY, width: cakeWidth, height: cakeHeight + topCakeHeight };
        }

        function drawFullCake() {
            const cakeWidth = canvas.width * 0.5; 
            const cakeHeight = cakeWidth * 0.5;
            const plateHeight = canvas.height * 0.02;

            const cakeY = canvas.height - cakeHeight - plateHeight;
            const cakeX = canvas.width / 2 - cakeWidth / 2;
            
            ctx.fillStyle = '#FFDDF4';
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + cakeHeight, cakeWidth / 2 + (canvas.width * 0.05), plateHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(cakeX, cakeY, cakeWidth, cakeHeight);
            
            const topCakeWidth = cakeWidth * 0.8;
            const topCakeHeight = cakeHeight * 0.5;
            const topCakeX = canvas.width / 2 - topCakeWidth / 2;
            const topCakeY = cakeY - topCakeHeight + 1;
            ctx.fillStyle = '#FFC0CB';
            ctx.fillRect(topCakeX, topCakeY, topCakeWidth, topCakeHeight);

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            const dripCount = 10;
            ctx.moveTo(topCakeX, topCakeY);
            for(let i=0; i < dripCount; i++) {
                ctx.quadraticCurveTo(topCakeX + (topCakeWidth / dripCount) * (i + 0.5), topCakeY + (topCakeHeight * 0.3), topCakeX + (topCakeWidth / dripCount) * (i + 1), topCakeY);
            }
            ctx.lineTo(topCakeX + topCakeWidth, topCakeY + (topCakeHeight * 0.4));
            ctx.lineTo(topCakeX, topCakeY + (topCakeHeight * 0.4));
            ctx.closePath();
            ctx.fill();

            const colors = ['#FF69B4', '#87CEEB', '#98FB98', '#FFD700', '#DDA0DD'];
            for(let i=0; i<30; i++) {
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.fillRect(topCakeX + (topCakeWidth * 0.1) + Math.random() * (topCakeWidth * 0.8), topCakeY + Math.random() * (topCakeHeight * 0.2), canvas.width * 0.007, canvas.width * 0.012);
            }

            const candleHeight = canvas.height * 0.12; 
            const candleWidth = candleHeight * 0.25;
            const candleX = canvas.width / 2 - candleWidth / 2;
            const candleY = topCakeY - candleHeight;
            
            if (isFlameOn) {
                const goldGradient = ctx.createLinearGradient(candleX, 0, candleX + candleWidth, 0);
                goldGradient.addColorStop(0, '#FFD700');
                goldGradient.addColorStop(0.5, '#FFFACD');
                goldGradient.addColorStop(1, '#FFDF00');
                ctx.fillStyle = goldGradient;
                ctx.fillRect(candleX, candleY, candleWidth, candleHeight);
                
                const wickHeight = candleHeight * 0.15;
                ctx.fillStyle = "#333";
                ctx.fillRect(canvas.width / 2 - (candleWidth * 0.1), candleY - wickHeight, candleWidth * 0.2, wickHeight); 
                updateAndDrawFlame(canvas.width / 2, candleY - wickHeight);
            }
        }

        function drawSplitCake() {
            // --- BAGIAN KIRI ---
            ctx.save();
            ctx.translate(-sliceAnimationOffset, 0);
            
            const leftClip = new Path2D();
            leftClip.moveTo(finalSlicePath[0].x, 0);
            finalSlicePath.forEach(p => leftClip.lineTo(p.x, p.y));
            leftClip.lineTo(finalSlicePath[finalSlicePath.length - 1].x, canvas.height);
            leftClip.lineTo(0, canvas.height);
            leftClip.lineTo(0, 0);
            leftClip.closePath();
            ctx.clip(leftClip);

            drawFullCake();
            ctx.restore();

            // --- BAGIAN KANAN ---
            ctx.save();
            ctx.translate(sliceAnimationOffset, 0);

            const rightClip = new Path2D();
            rightClip.moveTo(finalSlicePath[0].x, 0);
            finalSlicePath.forEach(p => rightClip.lineTo(p.x, p.y));
            rightClip.lineTo(finalSlicePath[finalSlicePath.length - 1].x, canvas.height);
            rightClip.lineTo(canvas.width, canvas.height);
            rightClip.lineTo(canvas.width, 0);
            rightClip.closePath();
            ctx.clip(rightClip);

            drawFullCake();
            ctx.restore();
        }
        
        function drawEnvelope() {
            const width = canvas.width * 0.6;
            const height = width * 0.6;
            const x = canvas.width / 2 - width / 2;
            const y = canvas.height / 2 - height / 2;
            envelopeRect = { x, y, width, height };

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#FFC0CB";
            ctx.fillRect(x, y, width, height);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + width / 2, y + height / 2);
            ctx.lineTo(x + width, y);
            ctx.closePath();
            ctx.strokeStyle = "#FF69B4";
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawLetter() {
            const width = canvas.width * 0.85;
            const height = canvas.height * 0.8;
            const x = canvas.width / 2 - width / 2;
            const y = canvas.height / 2 - height / 2;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#FFF8DC";
            ctx.strokeStyle = "#FFD700";
            ctx.lineWidth = 4;
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.strokeRect(x, y, width, height);
            ctx.fillRect(x, y, width, height);
            ctx.shadowBlur = 0;
            
            ctx.save();
            ctx.scale(-1, 1);
            ctx.fillStyle = "#C71585";
            ctx.font = `bold ${canvas.width * 0.12}px 'Dancing Script', cursive`;
            ctx.textAlign = "center";
            
            ctx.fillText("Selamat", -canvas.width / 2, y + height * 0.18);
            ctx.fillText("Ulang Tahun!", -canvas.width / 2, y + height * 0.30);

            ctx.fillStyle = "#2F4F4F";
            ctx.font = `${canvas.width * 0.06}px 'Dancing Script', cursive`;
            const message = "Semoga panjang umur, sehat selalu, dan semua harapanmu tercapai. Teruslah menjadi pribadi yang luar biasa!";
            const lines = [];
            let currentLine = '';
            message.split(' ').forEach(word => {
                if (ctx.measureText(currentLine + word).width > width * 0.8) {
                    lines.push(currentLine);
                    currentLine = word + ' ';
                } else {
                    currentLine += word + ' ';
                }
            });
            lines.push(currentLine);
            lines.forEach((line, index) => {
                ctx.fillText(line.trim(), -canvas.width / 2, y + height * 0.45 + (index * (canvas.width * 0.08)));
            });
            ctx.restore();
        }

        function drawFingerIndicator() {
            if (!fingerPosition) return;
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.beginPath();
            ctx.arc(fingerPosition.x, fingerPosition.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "rgba(255, 105, 180, 0.9)";
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function updateAndDrawSparkles() {
            if (sparkleParticles.length < 50) {
                sparkleParticles.push({
                    x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, size: Math.random() * 2 + 1, alpha: Math.random() * 0.5 + 0.2, decay: Math.random() * 0.01 + 0.005
                });
            }
            for (let i = sparkleParticles.length - 1; i >= 0; i--) {
                let p = sparkleParticles[i];
                p.alpha -= p.decay;
                if (p.alpha <= 0) {
                    sparkleParticles[i] = { x: Math.random() * bgCanvas.width, y: bgCanvas.height, size: Math.random() * 2 + 1, alpha: Math.random() * 0.5 + 0.5, decay: Math.random() * 0.01 + 0.005 };
                }
                bgCtx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                bgCtx.beginPath();
                bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }
        
        function updateAndDrawFlame(x, y) {
            const windStrength = isBlowing ? (canvas.width * 0.005) : 0;
            const flickerIntensity = isBlowing ? 1.5 : 1;
            if (flameParticles.length < 150) {
                for (let i = 0; i < 5; i++) {
                    let particleType;
                    const rand = Math.random();
                    if (rand < 0.1) particleType = 'core'; 
                    else if (rand < 0.2) particleType = 'spark';
                    else particleType = 'flame';

                    flameParticles.push({
                        x, y,
                        vx: ((Math.random() - 0.5) * 0.6 * flickerIntensity) + windStrength - ((x - (canvas.width / 2)) * 0.01),
                        vy: -Math.random() * (canvas.height * 0.0025) * flickerIntensity - 1,
                        radiusX: (Math.random() * (canvas.width * 0.015) + (canvas.width * 0.01)) / (isBlowing ? 1.5 : 1),
                        radiusY: (Math.random() * (canvas.width * 0.03) + (canvas.width * 0.02)) / (isBlowing ? 1.5 : 1),
                        alpha: 1,
                        type: particleType
                    });
                }
            }

            for (let i = flameParticles.length - 1; i >= 0; i--) {
                let p = flameParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.radiusX *= 0.95;
                p.radiusY *= 0.95;
                p.alpha -= 0.04;

                if (p.alpha <= 0 || p.radiusX <= 0) {
                    flameParticles.splice(i, 1);
                } else {
                    ctx.beginPath();
                    ctx.ellipse(p.x, p.y, p.radiusX, p.radiusY, 0, 0, Math.PI * 2);
                    
                    let color;
                    if (p.type === 'core') {
                        color = `rgba(173, 216, 230, ${p.alpha * 0.8})`; 
                    } else if (p.type === 'spark') {
                        color = `rgba(255, 215, 0, ${p.alpha})`;
                    } else {
                        color = `rgba(255, ${Math.random() * 150 + 50}, 0, ${p.alpha})`;
                    }
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }
        
        function createConfetti(x, y) {
            confettiParticles = []; 
            const colors = ['#FF69B4', '#87CEEB', '#98FB98', '#FFD700', '#DDA0DD', '#FFFFFF'];
            for (let i = 0; i < 150; i++) {
                confettiParticles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * (canvas.width * 0.02), 
                    vy: -Math.random() * (canvas.height * 0.015) - 5,
                    width: Math.random() * (canvas.width * 0.02) + 5,
                    height: Math.random() * (canvas.width * 0.03) + 5,
                    alpha: 1, 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    angle: Math.random() * Math.PI * 2,
                    spin: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function updateAndDrawConfetti() {
             for (let i = confettiParticles.length - 1; i >= 0; i--) {
                let p = confettiParticles[i];
                p.vx *= 0.99;
                p.x += p.vx;
                p.vy += 0.2; 
                p.y += p.vy;
                p.alpha -= 0.01;
                p.angle += p.spin;

                if (p.alpha <= 0) confettiParticles.splice(i, 1);
                else {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.alpha;
                    ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                    ctx.restore();
                }
            }
        }
        
        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = canvas.width - (event.clientX - rect.left) * scaleX;
            const clickY = (event.clientY - rect.top) * scaleY;

            if (isCakeCut) { 
                isFlameOn = true;
                isCakeCut = false;
                finalSlicePath = [];
                sliceAnimationOffset = 0;
                isCakeCuttable = false;
                slicePath = [];
                statusText.textContent = "Tiup lagi untuk memadamkannya!";
                return;
            }

            if (isLetterOpen) {
                isLetterOpen = false;
                isCakeCuttable = true;
                slicePath = [];
                statusText.textContent = "Sekarang, potong kuenya dengan jarimu!";
                return;
            }

            if (isEnvelopeVisible) {
                if (clickX > envelopeRect.x && clickX < envelopeRect.x + envelopeRect.width &&
                    clickY > envelopeRect.y && clickY < envelopeRect.y + envelopeRect.height) {
                    isEnvelopeVisible = false;
                    isLetterOpen = true;
                    statusText.textContent = "Selamat Ulang Tahun! Klik di mana saja untuk menutup.";
                }
            }
        });
        
        resizeCanvases();
    </script>
</body>
</html>
